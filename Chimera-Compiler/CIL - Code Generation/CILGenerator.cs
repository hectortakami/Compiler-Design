/*
  Chimera compiler - Program driver.
  Created by Hector Takami & Ernesto Cervantes
  Copyright (C) 2013 Ariel Ortiz, ITESM CEM
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;

namespace Chimera
{
    using VariableType = KeyValuePair<string, SymbolTable.Register>;

    class CILGenerator
    {
        //-----------------------------------------------------------
        public SymbolTable symbolTable
        {
            get;
            private set;
        }
        //-----------------------------------------------------------
        public ProcedureTable procedureTable
        {
            get;
            private set;
        }
        //-----------------------------------------------------------
       
        static readonly IDictionary<Type, string> CILTypes =
            new Dictionary<Type, string>() {
                { Type.BOOL, "bool" },
                { Type.INT, "int32" },              
                { Type.VOID, "void" }, 
                { Type.STR, "string" }, 
                { Type.LIST, "int32" }, 
                { Type.INT_LIST, "int32[]" },  
                { Type.STR_LIST, "string[]" }, 
                { Type.BOOL_LIST, "int32[]" }
            };

        //-----------------------------------------------------------
        // AUXILIARY SCOPE FLAG VARIABLES
        //-----------------------------------------------------------
        private string insideProcedure = "";
        private int labelCounter = 0;
        private int ifCounter = 0;
        private int elseCounter = 0;
        private int loopCounter = 0;
        
        //-----------------------------------------------------------
        public CILGenerator(SymbolTable symbolTable, ProcedureTable procedureTable)
        {
            this.symbolTable = symbolTable;
            this.procedureTable = procedureTable;
            this.builder.Clear();
        }
        //-----------------------------------------------------------
        


        //-----------------------------------------------------------
        // SEMANTIC CONTAINERS
        //-----------------------------------------------------------
        public void Visit(Program_Node node)
        {
            builder.AppendLine("// Code generated by the chimera compiler\n");
            builder.AppendLine("// Created by Hector Takami & Ernesto Cervantes\n");
            builder.AppendLine("// Copyright (C) 2013 Ariel Ortiz, ITESM CEM\n");
            builder.AppendLine(".assembly 'Chimera' {}");
            builder.AppendLine(".assembly extern 'ChimeraLib' {}");
            builder.AppendLine(".class public 'ChimeraProgram' extends ['mscorlib']'System'.'Object' {");
            builder.AppendLine();

            SymbolTable declVartable = symbolTable;
            string declaredVariables;
            var locals = declVartable.Where(kv => kv.Value.procType != ProcedureType.PARAM).OrderBy(kv => kv.Value.pos);
            StringBuilder declBuilder = new StringBuilder();
            
            foreach (var global in locals)
                {

                    string globalVarType = CILTypes[global.Value.type];
                    if (globalVarType == null){
                        throw new Exception($"Could not find CIL type for: {global.Value.type}");
                    }
                    declBuilder.AppendLine($"\t.field public static {globalVarType} '{global.Key}'");
                }
            declaredVariables = declBuilder.ToString();
            builder.AppendLine(declaredVariables);

            Visit((dynamic)node[node.Count() - 2]);

            builder.AppendLine("\t.method public static void main(){");
            builder.AppendLine("\t\t.entrypoint");
            builder.AppendLine();

            StringBuilder stringBuilder = new StringBuilder();
            SymbolTable table = symbolTable;
            string variablesInScope;

            var dlocals = table.Where(kv => kv.Value.procType != ProcedureType.PARAM).OrderBy(kv => kv.Value.pos);

            foreach (var global in dlocals)
            {
                StringBuilder globalBuilder = new StringBuilder();

                StringBuilder result = new StringBuilder();
                int index = 0;
                SymbolTable.Register row = global.Value;
                string cilValue;
                switch (row.type)
                {
                    case Type.BOOL:
                        var b = row.value ? 1 : 0;
                        cilValue = $"ldc.i4.{b}";
                        break;
                    case Type.INT:
                        cilValue = $"ldc.i4 {row.value}";
                        break;
                    case Type.STR:
                        string s = row.value;
                        s = s.Count() == 0 ? "\"\"" : s;
                        cilValue = $"ldstr {s}";
                        break;
                    case Type.BOOL_LIST:
                        bool[] constBoolArr = row.value as bool[];
                        result.AppendLine($"ldc.i4 {constBoolArr.Length}");
                        result.AppendLine("\t\tnewarr int32");
                        foreach (bool val in constBoolArr)
                        {
                            result.AppendLine($"\t\tdup");
                            result.AppendLine($"\t\tldc.i4 {index++}");
                            result.AppendLine($"\t\tldc.i4.{(val ? 1 : 0)}");
                            result.AppendLine($"\t\tstelem.i4");
                        }
                        cilValue = result.ToString();
                        break;
                    case Type.INT_LIST:
                        int[] constIntArr = row.value as int[];
                        result.AppendLine($"ldc.i4 {constIntArr.Length}");
                        result.AppendLine("\t\tnewarr int32");
                        foreach (int val in constIntArr)
                        {
                            result.AppendLine($"\t\tdup");
                            result.AppendLine($"\t\tldc.i4 {index++}");
                            result.AppendLine($"\t\tldc.i4 {val}");
                            result.AppendLine($"\t\tstelem.i4");
                        }
                        cilValue = result.ToString();
                        break;
                    case Type.STR_LIST:
                        string[] constStrArr = row.value as string[];
                        result.AppendLine($"ldc.i4 {constStrArr.Length}");
                        result.AppendLine("\t\tnewarr string");
                        foreach (string val in constStrArr)
                        {
                            result.AppendLine($"\t\tdup");
                            result.AppendLine($"\t\tldc.i4 {index++}");
                            result.AppendLine($"\t\tldstr {val}");
                            result.AppendLine($"\t\tstelem.ref");
                        }
                        cilValue = result.ToString();
                        break;
                    case Type.VOID:
                        cilValue = "";
                        break;
                    default:
                        throw new Exception($"Could not find value for: {global.Key}");
                }
                globalBuilder.AppendLine($"\t\t{cilValue}");

                string staticVariableType = CILTypes[global.Value.type];
                    if (staticVariableType == null){
                        throw new Exception($"Could not find CIL type for: {global.Value.type}");
                    }

                globalBuilder.AppendLine($"\t\tstsfld {staticVariableType} class ['Chimera']'ChimeraProgram'::'{global.Key}'");
                stringBuilder.Append(globalBuilder.ToString());
            }

            variablesInScope = stringBuilder.ToString();
            builder.AppendLine(variablesInScope);
            Visit((dynamic)node.Last());
            builder.AppendLine("\t\tret");
            builder.AppendLine("\t}");
            builder.AppendLine("}");
        }
        //-----------------------------------------------------------
        public void Visit(Statement_List node)
        {
            VisitChildren(node);
        }
        //-----------------------------------------------------------
        public void Visit(Constant_List node)
        {
            return;
        }
        //-----------------------------------------------------------
        public void Visit(Procedure_List node)
        {
            VisitChildren(node);
        }
        //-----------------------------------------------------------


        //-----------------------------------------------------------
        // DECLARATIONS
        //-----------------------------------------------------------
        public void Visit(Constant_Declaration node)
        {
            return;
        }
        //-----------------------------------------------------------
        public void Visit(Variable_Declaration node)
        {
            return;
        }
        //-----------------------------------------------------------
        public void Visit(Procedure_Declaration node)
        {
            var procedureName = node.AnchorToken.Lexeme;
            var procedure = procedureTable[procedureName];
            Type type = procedure.type;

            string returnType;
            switch (type)
            {
                case Type.BOOL:
                    returnType = "bool";
                    break;
                case Type.INT:
                    returnType = "int32";
                    break;
                case Type.STR:
                    returnType = "string";
                    break;
                case Type.BOOL_LIST:
                case Type.INT_LIST:
                    returnType = "int32[]";
                    break;
                case Type.STR_LIST:
                    returnType = "string[]";
                    break;
                case Type.VOID:
                    returnType = "void";
                    break;
                default:
                    throw new Exception($"Could not find CIL type for: {type}");
            }

            var lastScope = insideProcedure;
            insideProcedure = procedureName;

            builder.Append($"\t.method public static {returnType} '{procedureName}'(");

            StringBuilder paramBuilder = new StringBuilder();

            SymbolTable table;
            if (procedureName == "")
            {
                table = symbolTable;
            }
            else
            {
                table = procedureTable[procedureName].symbols;
            }
            var _params = table.Where(kv => kv.Value.procType == ProcedureType.PARAM).OrderBy(kv => kv.Value.pos);

            var start = true;
            foreach (var param in _params)
            {
                if (!start)
                {
                    paramBuilder.Append(", ");
                }
                start = false;
                string localVarType;
                switch (param.Value.type)
                {
                    case Type.BOOL:
                        localVarType = "bool";
                        break;
                    case Type.INT:
                        localVarType = "int32";
                        break;
                    case Type.STR:
                        localVarType = "string";
                        break;
                    case Type.BOOL_LIST:
                    case Type.INT_LIST:
                        localVarType = "int32[]";
                        break;
                    case Type.STR_LIST:
                        localVarType = "string[]";
                        break;
                    case Type.VOID:
                        localVarType = "void";
                        break;
                    default:
                        throw new Exception($"Could not find CIL type for: {param.Value.type}");
                }
                string parameter = $"{localVarType} {param.Key}";
                paramBuilder.Append(parameter);
            }
            builder.Append(paramBuilder.ToString());



            builder.AppendLine("){");
            SymbolTable declVarTable;
            string declaredVariables;
            if (procedureName == "")
            {
                declVarTable = symbolTable;
            }
            else
            {
                declVarTable = procedureTable[procedureName].symbols;
            }
            var locals = declVarTable.Where(kv => kv.Value.procType != ProcedureType.PARAM).OrderBy(kv => kv.Value.pos);
            var declStart = true;
            StringBuilder stringBuilder = new StringBuilder();
            if (procedureName == "")
            {
                foreach (var global in locals)
                {
                    string globalVarType;
                    switch (global.Value.type)
                    {
                        case Type.BOOL:
                            globalVarType = "bool";
                            break;
                        case Type.INT:
                            globalVarType = "int32";
                            break;
                        case Type.STR:
                            globalVarType = "string";
                            break;
                        case Type.BOOL_LIST:
                        case Type.INT_LIST:
                            globalVarType = "int32[]";
                            break;
                        case Type.STR_LIST:
                            globalVarType = "string[]";
                            break;
                        case Type.VOID:
                            globalVarType = "void";
                            break;
                        default:
                            throw new Exception($"Could not find CIL type for: {global.Value.type}");
                    }
                    stringBuilder.AppendLine($"\t.field public static {globalVarType} '{global.Key}'");
                }
            }
            else
            {
                stringBuilder.Append("\t\t.locals init (");
                declStart = true;
                foreach (var local in locals)
                {
                    if (!declStart)
                    {
                        stringBuilder.Append(", ");
                    }
                    stringBuilder.AppendLine();
                    declStart = false;

                    string localVarType;
                    switch (local.Value.type)
                    {
                        case Type.BOOL:
                            localVarType = "bool";
                            break;
                        case Type.INT:
                            localVarType = "int32";
                            break;
                        case Type.STR:
                            localVarType = "string";
                            break;
                        case Type.BOOL_LIST:
                        case Type.INT_LIST:
                            localVarType = "int32[]";
                            break;
                        case Type.STR_LIST:
                            localVarType = "string[]";
                            break;
                        case Type.VOID:
                            localVarType = "void";
                            break;
                        default:
                            throw new Exception($"Could not find CIL type for: {local.Value.type}");
                    }
                    string variable = $"{localVarType} {local.Key}";
                    stringBuilder.Append($"\t\t\t{variable}");



                }
                stringBuilder.AppendLine();
                stringBuilder.AppendLine("\t\t)");
            }
            declaredVariables = stringBuilder.ToString();
            builder.AppendLine(declaredVariables);

            StringBuilder variablesBuilder = new StringBuilder();
            SymbolTable variablesTable;
            string variablesInScope;
            if (insideProcedure == "")
            {
                variablesTable = symbolTable;
            }
            else
            {
                variablesTable = procedureTable[insideProcedure].symbols;
            }

            var dlocals = variablesTable.Where(kv => kv.Value.procType != ProcedureType.PARAM).OrderBy(kv => kv.Value.pos);

            if (insideProcedure == "")
            {
                foreach (var global in dlocals)
                {
                    StringBuilder globalBuilder = new StringBuilder();

                    StringBuilder result = new StringBuilder();
                    int index = 0;
                    SymbolTable.Register row = global.Value;
                    string cilValue;
                    switch (row.type)
                    {
                        case Type.BOOL:
                            var b = row.value ? 1 : 0;
                            cilValue = $"ldc.i4.{b}";
                            break;
                        case Type.INT:
                            cilValue = $"ldc.i4 {row.value}";
                            break;
                        case Type.STR:
                            string s = row.value;
                            s = s.Count() == 0 ? "\"\"" : s;
                            cilValue = $"ldstr {s}";
                            break;
                        case Type.BOOL_LIST:
                            bool[] constBoolArr = row.value as bool[];
                            result.AppendLine($"ldc.i4 {constBoolArr.Length}");
                            result.AppendLine("\t\tnewarr int32");
                            foreach (bool val in constBoolArr)
                            {
                                result.AppendLine($"\t\tdup");
                                result.AppendLine($"\t\tldc.i4 {index++}");
                                result.AppendLine($"\t\tldc.i4.{(val ? 1 : 0)}");
                                result.AppendLine($"\t\tstelem.i4");
                            }
                            cilValue = result.ToString();
                            break;
                        case Type.INT_LIST:
                            int[] constIntArr = row.value as int[];
                            result.AppendLine($"ldc.i4 {constIntArr.Length}");
                            result.AppendLine("\t\tnewarr int32");
                            foreach (int val in constIntArr)
                            {
                                result.AppendLine($"\t\tdup");
                                result.AppendLine($"\t\tldc.i4 {index++}");
                                result.AppendLine($"\t\tldc.i4 {val}");
                                result.AppendLine($"\t\tstelem.i4");
                            }
                            cilValue = result.ToString();
                            break;
                        case Type.STR_LIST:
                            string[] constStrArr = row.value as string[];
                            result.AppendLine($"ldc.i4 {constStrArr.Length}");
                            result.AppendLine("\t\tnewarr string");
                            foreach (string val in constStrArr)
                            {
                                result.AppendLine($"\t\tdup");
                                result.AppendLine($"\t\tldc.i4 {index++}");
                                result.AppendLine($"\t\tldstr {val}");
                                result.AppendLine($"\t\tstelem.ref");
                            }
                            cilValue = result.ToString();
                            break;
                        case Type.VOID:
                            cilValue = "";
                            break;
                        default:
                            throw new Exception($"Could not find value for: {global.Key}");
                    }
                    globalBuilder.AppendLine($"\t\t{cilValue}");

                    string staticVariableType;
                    switch (global.Value.type)
                    {
                        case Type.BOOL:
                            staticVariableType = "bool";
                            break;
                        case Type.INT:
                            staticVariableType = "int32";
                            break;
                        case Type.STR:
                            staticVariableType = "string";
                            break;
                        case Type.BOOL_LIST:
                        case Type.INT_LIST:
                            staticVariableType = "int32[]";
                            break;
                        case Type.STR_LIST:
                            staticVariableType = "string[]";
                            break;
                        case Type.VOID:
                            staticVariableType = "void";
                            break;
                        default:
                            throw new Exception($"Could not find CIL type for: {global.Value.type}");
                    }

                    globalBuilder.AppendLine($"\t\tstsfld {staticVariableType} class ['Chimera']'ChimeraProgram'::'{global.Key}'");
                    variablesBuilder.Append(globalBuilder.ToString());
                }
            }
            else
            {
                foreach (var local in locals)
                {
                    StringBuilder localStringBuilder = new StringBuilder();

                    StringBuilder result = new StringBuilder();
                    int index = 0;
                    SymbolTable.Register row = local.Value;
                    string cilValue;
                    switch (row.type)
                    {
                        case Type.BOOL:
                            var b = row.value ? 1 : 0;
                            cilValue = $"ldc.i4.{b}";
                            break;
                        case Type.INT:
                            cilValue = $"ldc.i4 {row.value}";
                            break;
                        case Type.STR:
                            string s = row.value;
                            s = s.Count() == 0 ? "\"\"" : s;
                            cilValue = $"ldstr {s}";
                            break;
                        case Type.BOOL_LIST:
                            bool[] constBoolArr = row.value as bool[];
                            result.AppendLine($"ldc.i4 {constBoolArr.Length}");
                            result.AppendLine("\t\tnewarr int32");
                            foreach (bool val in constBoolArr)
                            {
                                result.AppendLine($"\t\tdup");
                                result.AppendLine($"\t\tldc.i4 {index++}");
                                result.AppendLine($"\t\tldc.i4.{(val ? 1 : 0)}");
                                result.AppendLine($"\t\tstelem.i4");
                            }
                            cilValue = result.ToString();
                            break;
                        case Type.INT_LIST:
                            int[] constIntArr = row.value as int[];
                            result.AppendLine($"ldc.i4 {constIntArr.Length}");
                            result.AppendLine("\t\tnewarr int32");
                            foreach (int val in constIntArr)
                            {
                                result.AppendLine($"\t\tdup");
                                result.AppendLine($"\t\tldc.i4 {index++}");
                                result.AppendLine($"\t\tldc.i4 {val}");
                                result.AppendLine($"\t\tstelem.i4");
                            }
                            cilValue = result.ToString();
                            break;
                        case Type.STR_LIST:
                            string[] constStrArr = row.value as string[];
                            result.AppendLine($"ldc.i4 {constStrArr.Length}");
                            result.AppendLine("\t\tnewarr string");
                            foreach (string val in constStrArr)
                            {
                                result.AppendLine($"\t\tdup");
                                result.AppendLine($"\t\tldc.i4 {index++}");
                                result.AppendLine($"\t\tldstr {val}");
                                result.AppendLine($"\t\tstelem.ref");
                            }
                            cilValue = result.ToString();
                            break;
                        case Type.VOID:
                            cilValue = "";
                            break;
                        default:
                            throw new Exception($"Could not find value for: {local.Key}");
                    }

                    localStringBuilder.AppendLine($"\t\t{cilValue}");
                    localStringBuilder.AppendLine($"\t\tstloc '{local.Key}'");
                    stringBuilder.Append(localStringBuilder.ToString());
                }
            }
            variablesInScope = stringBuilder.ToString();
            builder.AppendLine(variablesInScope);

            if (node.Last() is Statement_List)
            {
                Visit((dynamic)node.Last());
            }

            builder.AppendLine("\t\tret");
            builder.AppendLine("\t}");

            insideProcedure = lastScope;
        }
        //-----------------------------------------------------------
        public void Visit(Parameter_Declaration node)
        {
            return;
        }
        //-----------------------------------------------------------


        //-----------------------------------------------------------
        // STATEMENTS
        //-----------------------------------------------------------
        public void Visit(Assignment_Statement node)
        {
            Node first = node[0];
            if (first is ListIndexNode)
            {
                (first as ListIndexNode).isAssignment = true;
            }
            else if (first is IdentifierNode)
            {
                (first as IdentifierNode).isAssignment = true;
            }
            Visit((dynamic)node[0]);
            Visit((dynamic)node[1]);
            if (node[0] is ListIndexNode)
            {
                Type type = node[0].extra;
                switch (type)
                {
                    case Type.BOOL_LIST:
                    case Type.INT_LIST:
                        builder.AppendLine("\t\tstelem.i4");
                        break;
                    case Type.STR_LIST:
                        builder.AppendLine("\t\tstelem.ref");
                        break;
                }
            }
            else
            {
                string varName = node[0].AnchorToken.Lexeme;
                PushSymbol(varName);
            }
        }
        //-----------------------------------------------------------
        public void Visit(Loop_Statement node)
        {
            var lastId = labelCounter;
            labelCounter = loopCounter++;
            builder.AppendLine($"\tloop_{labelCounter}:");
            VisitChildren(node);
            builder.AppendLine($"\t\tbr loop_{labelCounter}");
            builder.AppendLine($"\tend_{labelCounter}:");

            labelCounter = lastId;
        }
        //-----------------------------------------------------------
        public void Visit(For_Statement node)
        {
            var lastId = labelCounter;
            labelCounter = loopCounter++;

            string varName = node[0].AnchorToken.Lexeme;
            string indexVarName = $"__{varName}_index";
            builder.AppendLine("\t\tldc.i4.0");
            PushSymbol(indexVarName);

            Visit((dynamic)node[1]);
            builder.AppendLine($"\tfor_{labelCounter}:");
            builder.AppendLine($"\t\tdup");
            PopSymbol(indexVarName);
            switch (ObtainSymbolByKey(varName).type)
            {
                case Type.BOOL:
                case Type.INT:
                    builder.AppendLine($"\t\tldelem.i4");
                    break;
                default:
                    builder.AppendLine($"\t\tldelem.ref");
                    break;

            }
            PushSymbol(varName);

            builder.AppendLine();
            Visit((dynamic)node[2]);

            builder.AppendLine();
            PopSymbol(indexVarName);
            builder.AppendLine("\t\tldc.i4.1");
            builder.AppendLine("\t\tadd");
            PushSymbol(indexVarName);

            builder.AppendLine($"\tnext_{labelCounter}:");
            builder.AppendLine($"\t\tdup");
            builder.AppendLine($"\t\tldlen");
            builder.AppendLine($"\t\tconv.i4");
            PopSymbol(indexVarName);
            builder.AppendLine($"\t\tbgt for_{labelCounter}");

            builder.AppendLine($"\tend_{labelCounter}:");
            builder.AppendLine($"\t\tpop");

            labelCounter = lastId;
        }
        //-----------------------------------------------------------
        public void Visit(Exit_Statement node)
        {
            builder.AppendLine($"\t\tbr end_{labelCounter}");
        }
        //-----------------------------------------------------------
        public void Visit(If_Statement node)
        {
            ifCounter = loopCounter++;
            int previousElseCount = elseCounter;
            elseCounter = 0;

            builder.AppendLine();
            builder.AppendLine($"\tIf_{ifCounter}_0_condition:");
            Visit((dynamic)node[0]);
            builder.AppendLine($"\t\tbrzero If_{ifCounter}_1_condition");

            builder.AppendLine($"\tIf_{ifCounter}_0_body:");
            Visit((dynamic)node[1]);
            builder.AppendLine($"\t\tbr If_{ifCounter}_End");
            builder.AppendLine();

            VisitChildren(node, 2);
            builder.AppendLine($"\tIf_{ifCounter}_{elseCounter + 1}_condition:");
            builder.AppendLine($"\tIf_{ifCounter}_End:");

            elseCounter = previousElseCount;
        }
        //-----------------------------------------------------------
        public void Visit(Condition_List node)
        {
            VisitChildren(node);
        }
        //-----------------------------------------------------------
        public void Visit(Elif_Statement node)
        {
            elseCounter++;
            builder.AppendLine($"\tIf_{ifCounter}_{elseCounter}_condition:");
            Visit((dynamic)node[0]);
            builder.AppendLine($"\t\tbrzero If_{ifCounter}_{elseCounter + 1}_condition");
            builder.AppendLine();

            builder.AppendLine($"\tIf_{ifCounter}_{elseCounter}_body:");
            VisitChildren(node, 1);
            builder.AppendLine($"\t\tbr If_{ifCounter}_End");
            builder.AppendLine();
        }
        //-----------------------------------------------------------
        public void Visit(Else_Statement node)
        {
            elseCounter++;
            builder.AppendLine($"\tIf_{ifCounter}_{elseCounter}_condition:");
            VisitChildren(node);
            builder.AppendLine($"\t\tbr If_{ifCounter}_End");
            builder.AppendLine();
        }
        //-----------------------------------------------------------
        public void Visit(Return_Statement node)
        {
            bool returnsSomething = node.Count() != 0;
            string procedureName = insideProcedure;
            Type returnType = procedureTable[procedureName].type;

            if (returnsSomething)
            {
                Visit((dynamic)node[0]);
            }
            else
            {
                string defaultValue;
                switch (returnType)
                {
                    case Type.BOOL:
                    case Type.INT:
                        defaultValue = "ldc.i4.0";
                        break;
                    case Type.STR:
                        defaultValue = "ldstr \"\"";
                        break;
                    case Type.BOOL_LIST:
                    case Type.INT_LIST:
                        defaultValue = "ldc.i4.0\nnewarr int32";
                        break;
                    case Type.STR_LIST:
                        defaultValue = "ldc.i4.0\nnewarr string";
                        break;
                    case Type.VOID:
                        defaultValue = "";
                        break;
                    default:
                        throw new Exception($"Could not find CIL type for: {returnType}");
                }
                builder.AppendLine($"\t\t{defaultValue}");
            }
            builder.AppendLine("\t\tret");
        }
        //-----------------------------------------------------------
        public void Visit(Call_Statement node)
        {
            string procedureName = node.AnchorToken.Lexeme;
            var procedure = procedureTable[procedureName];

            string returnType;
            switch (procedure.type)
            {
                case Type.BOOL:
                    returnType = "bool";
                    break;
                case Type.INT:
                    returnType = "int32";
                    break;
                case Type.STR:
                    returnType = "string";
                    break;
                case Type.BOOL_LIST:
                case Type.INT_LIST:
                    returnType = "int32[]";
                    break;
                case Type.STR_LIST:
                    returnType = "string[]";
                    break;
                case Type.VOID:
                    returnType = "void";
                    break;
                default:
                    throw new Exception($"Could not find CIL type for: {procedure.type}");

            }

            string _prefix = "";

            if (procedure.isPredefined)
            {
                _prefix = "['ChimeraLib']'Chimera'.Lib";
            }
            else
            {
                _prefix = "['Chimera']'ChimeraProgram'";
            }

            VisitChildren(node);
            builder.Append($"\t\tcall {returnType} class {_prefix}::'{procedureName}'(");

            SymbolTable table;
            if (procedureName == "")
            {
                table = symbolTable;
            }
            else
            {
                table = procedureTable[procedureName].symbols;
            }
            var _params = table.Where(kv => kv.Value.procType == ProcedureType.PARAM).OrderBy(kv => kv.Value.pos);
            var start = true;
            foreach (var param in _params)
            {
                if (!start)
                {
                    builder.Append(",");
                }
                start = false;

                string paramType;
                switch (param.Value.type)
                {
                    case Type.BOOL:
                        paramType = "bool";
                        break;
                    case Type.INT:
                        paramType = "int32";
                        break;
                    case Type.STR:
                        paramType = "string";
                        break;
                    case Type.BOOL_LIST:
                    case Type.INT_LIST:
                        paramType = "int32[]";
                        break;
                    case Type.STR_LIST:
                        paramType = "string[]";
                        break;
                    case Type.VOID:
                        paramType = "void";
                        break;
                    default:
                        throw new Exception($"Could not find CIL type for: {param.Value.type}");

                }
                builder.Append($"{paramType}");
            }
            builder.AppendLine(")");


            var callProcedureName = node.AnchorToken.Lexeme;
            Type type = procedureTable[callProcedureName].type;
            if (type != Type.VOID)
            {
                builder.AppendLine("pop");
            }
        }
        //-----------------------------------------------------------


        //-----------------------------------------------------------
        // VARIABLES TYPES
        //-----------------------------------------------------------
        public void Visit(IntNode node)
        {
            builder.AppendLine("int32");
        }
        //-----------------------------------------------------------
        public void Visit(StrNode node)
        {
            builder.AppendLine("string");
        }
        //-----------------------------------------------------------
        public void Visit(BoolNode node)
        {
            builder.Append("bool");
        }
        //-----------------------------------------------------------
        public void Visit(VoidTypeNode node)
        {
            builder.Append("void");
        }
        //-----------------------------------------------------------
        public void Visit(ListTypeNode node)
        {
            Visit((dynamic)Node.fromToken(node.AnchorToken));
            builder.Append("[]");
        }
        //-----------------------------------------------------------


        //-----------------------------------------------------------
        // LITERAL TYPES
        //-----------------------------------------------------------
        public void Visit(IntLiteralNode node)
        {
            builder.AppendLine($"\t\tldc.i4 {node.AnchorToken.Lexeme}");
        }
        //-----------------------------------------------------------
        public void Visit(StrLiteralNode node)
        {
            var tmp = node.AnchorToken.Lexeme.Substring(1, node.AnchorToken.Lexeme.Length - 2).Replace("\"\"", "\\\"");
            string escapeString = $"\"{tmp}\"";
            builder.AppendLine($"\t\tldstr {escapeString}");
        }
        //-----------------------------------------------------------
        public void Visit(TrueNode node)
        {
            builder.AppendLine($"\t\tldc.i4.1");
        }
        //-----------------------------------------------------------
        public void Visit(FalseNode node)
        {
            builder.AppendLine($"\t\tldc.i4.0");
        }
        //-----------------------------------------------------------
        public void Visit(ListLiteralNode node)
        {
            builder.AppendLine($"\t\tldc.i4 {node.Count()}");
            string listType = "";
            string elementType = "";
            if (node[0] is IntLiteralNode)
            {
                listType = "int32";
                elementType = "i4";
            }
            else if ((node[0] is TrueNode) || (node[0] is FalseNode))
            {
                listType = "bool";
                elementType = "i4";
            }
            else if (node[0] is StrLiteralNode)
            {
                listType = "string";
                elementType = "ref";
            }
            builder.AppendLine($"\t\tnewarr {listType}");
            int index = 0;
            foreach (var n in node)
            {
                builder.AppendLine("\t\tdup");
                builder.AppendLine($"\t\tldc.i4 {index}");
                Visit((dynamic)n);

                builder.AppendLine($"\t\tstelem.{elementType}");
                index++;
            }
        }
        //-----------------------------------------------------------
        public void Visit(ListIndexNode node)
        {
            Visit((dynamic)node[0]);
            Visit((dynamic)node[1]);
            Type type = node.extra;
            if (!node.isAssignment)
            {
                switch (type)
                {
                    case Type.BOOL_LIST:
                    case Type.INT_LIST:
                        builder.AppendLine("\t\tldelem.i4");
                        break;
                    case Type.STR_LIST:
                        builder.AppendLine("\t\tldelem.ref");
                        break;
                }
            }
        }
        //-----------------------------------------------------------


        //-----------------------------------------------------------
        // EXPRESSION NODES
        //-----------------------------------------------------------
        public void Visit(IdentifierNode node)
        {
            string varName = node.AnchorToken.Lexeme;
            if (!node.isAssignment)
            {
                PopSymbol(varName);
            }
        }
        //-----------------------------------------------------------
        public void Visit(Call_Expression node)
        {
            string procedureName = node.AnchorToken.Lexeme;
            var procedure = procedureTable[procedureName];

            string returnType;
            switch (procedure.type)
            {
                case Type.BOOL:
                    returnType = "bool";
                    break;
                case Type.INT:
                    returnType = "int32";
                    break;
                case Type.STR:
                    returnType = "string";
                    break;
                case Type.BOOL_LIST:
                case Type.INT_LIST:
                    returnType = "int32[]";
                    break;
                case Type.STR_LIST:
                    returnType = "string[]";
                    break;
                case Type.VOID:
                    returnType = "void";
                    break;
                default:
                    throw new Exception($"Could not find CIL type for: {procedure.type}");

            }

            string _prefix = "";

            if (procedure.isPredefined)
            {
                _prefix = "['ChimeraLib']'Chimera'.Lib";
            }
            else
            {
                _prefix = "['Chimera']'ChimeraProgram'";
            }

            VisitChildren(node);
            builder.Append($"\t\tcall {returnType} class {_prefix}::'{procedureName}'(");

            SymbolTable table;
            if (procedureName == "")
            {
                table = symbolTable;
            }
            else
            {
                table = procedureTable[procedureName].symbols;
            }

            var _params = table.Where(kv => kv.Value.procType == ProcedureType.PARAM).OrderBy(kv => kv.Value.pos);
            var start = true;
            foreach (var param in _params)
            {
                if (!start)
                {
                    builder.Append(",");
                }
                start = false;

                string paramType;
                switch (param.Value.type)
                {
                    case Type.BOOL:
                        paramType = "bool";
                        break;
                    case Type.INT:
                        paramType = "int32";
                        break;
                    case Type.STR:
                        paramType = "string";
                        break;
                    case Type.BOOL_LIST:
                    case Type.INT_LIST:
                        paramType = "int32[]";
                        break;
                    case Type.STR_LIST:
                        paramType = "string[]";
                        break;
                    case Type.VOID:
                        paramType = "void";
                        break;
                    default:
                        throw new Exception($"Could not find CIL type for: {param.Value.type}");

                }
                builder.Append($"{paramType}");
            }
            builder.AppendLine(")");
        }
        //-----------------------------------------------------------


        //-----------------------------------------------------------
        // OPERATORS
        //-----------------------------------------------------------
        public void Visit(AndNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tand");
        }
        //-----------------------------------------------------------
        public void Visit(OrNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tor");
        }
        //-----------------------------------------------------------
        public void Visit(XORNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\txor");
        }
        //-----------------------------------------------------------
        public void Visit(CompNode node)
        {
            Visit((dynamic)node[0]);
            builder.AppendLine("\t\tldc.i4.1");
            builder.AppendLine("\t\txor");
        }
        //-----------------------------------------------------------
        public void Visit(EqualNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tceq");
        }
        //-----------------------------------------------------------
        public void Visit(InequalNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tceq");
            builder.AppendLine("\t\tldc.i4.1");
            builder.AppendLine("\t\txor");
        }
        //-----------------------------------------------------------
        public void Visit(LessNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tclt");
        }
        //-----------------------------------------------------------
        public void Visit(GreaterNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tcgt");
        }
        //-----------------------------------------------------------
        public void Visit(LessEqualNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tcgt");
            builder.AppendLine("\t\tldc.i4.1");
            builder.AppendLine("\t\txor");
        }
        //-----------------------------------------------------------
        public void Visit(GreaterEqualNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tclt");
            builder.AppendLine("\t\tldc.i4.1");
            builder.AppendLine("\t\txor");
        }
        //-----------------------------------------------------------
        public void Visit(SubNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tsub.ovf");
        }
        //-----------------------------------------------------------
        public void Visit(AddNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tadd.ovf");
        }
        //-----------------------------------------------------------
        public void Visit(MulNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tmul.ovf");
        }
        //-----------------------------------------------------------
        public void Visit(QuoNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\tdiv");
        }
        //-----------------------------------------------------------
        public void Visit(RemNode node)
        {
            VisitChildren(node);
            builder.AppendLine("\t\trem");
        }
        //-----------------------------------------------------------



        //-----------------------------------------------------------
        // MISCELLANEOUS FUNCTIONS
        //-----------------------------------------------------------
        void VisitChildren(Node node, int skip = 0, int take = 0)
        {
            skip = Math.Min(skip, node.Count());
            if (take == 0)
            {
                take = node.Count() - skip;
            }
            foreach (var n in node.Skip(skip).Take(take))
            {
                Visit((dynamic)n);
            }
        }
        void VisitBinaryOperator(Node node, Type type)
        {
            if (Visit((dynamic)node[0]) != type ||
                Visit((dynamic)node[1]) != type)
            {
                throw new SemanticError(
                    System.String.Format(
                        "Operator {0} requires two operands of type {1}",
                        node.AnchorToken.Lexeme,
                        type),
                    node.AnchorToken);
            }
        }
        //-----------------------------------------------------------
        SymbolTable.Register ObtainSymbolByKey(string key)
        {
            if (insideProcedure.Length > 0 && procedureTable[insideProcedure].symbols.Contains(key))
            {
                return procedureTable[insideProcedure].symbols[key];
            }
            else if (symbolTable.Contains(key))
            {
                return symbolTable[key];
            }
            else
            {
                return null;
            }

        }
        //-----------------------------------------------------------
        private void PopSymbol(string varName)
        {
            // Loads from the stack the value of the symbol (variable) if there's any key related
            var symbol = ObtainSymbolByKey(varName);
            if (symbol.procType == ProcedureType.PARAM)
            {
                builder.AppendLine($"\t\tldarg {varName}");
            }
            else if (insideProcedure != "" && procedureTable[insideProcedure].symbols.Contains(varName))
            {
                builder.AppendLine($"\t\tldloc {varName}");
            }
            else
            {
                string symbolType;
                switch (symbol.type)
                {
                    case Type.BOOL:
                        symbolType = "bool";
                        break;
                    case Type.INT:
                        symbolType = "int32";
                        break;
                    case Type.STR:
                        symbolType = "string";
                        break;
                    case Type.BOOL_LIST:
                    case Type.INT_LIST:
                        symbolType = "int32[]";
                        break;
                    case Type.STR_LIST:
                        symbolType = "string[]";
                        break;
                    case Type.VOID:
                        symbolType = "void";
                        break;
                    default:
                        throw new Exception($"Could not find CIL type for: {symbol.type}");
                }
                builder.AppendLine($"\t\tldsfld {symbolType} class ['Chimera']'ChimeraProgram'::'{varName}'");
            }
        }
        //-----------------------------------------------------------
        private void PushSymbol(string varName)
        {
            // Stores in the stack the value of the symbol (variable)
            var symbol = ObtainSymbolByKey(varName);
            string varType;
            switch (symbol.type)
            {
                case Type.BOOL:
                    varType = "bool";
                    break;
                case Type.INT:
                    varType = "int32";
                    break;
                case Type.STR:
                    varType = "string";
                    break;
                case Type.BOOL_LIST:
                case Type.INT_LIST:
                    varType = "int32[]";
                    break;
                case Type.STR_LIST:
                    varType = "string[]";
                    break;
                case Type.VOID:
                    varType = "void";
                    break;
                default:
                    throw new Exception($"Could not find CIL type for: {symbol.type}");
            }

            if (insideProcedure != "" && procedureTable[insideProcedure].symbols.Contains(varName))
            {
                if (symbol.procType == ProcedureType.PARAM)
                {
                    builder.AppendLine($"\t\tstarg {varName}");
                }
                else
                {
                    builder.AppendLine($"\t\tstloc {varName}");
                }
            }
            else
            {
                builder.AppendLine($"\t\tstsfld {varType} class ['Chimera']'ChimeraProgram'::'{varName}'");
            }
        }
        //-----------------------------------------------------------
        private StringBuilder builder = new StringBuilder();
       
        public override string ToString()
        {
            return builder.ToString();
        }
        //-----------------------------------------------------------
    }
}
